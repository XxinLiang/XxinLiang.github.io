---
layout: post

title: ES6从入门到放弃-let、const与解构赋值

date: 2016-05-10

categories: blog

tags: [ES6,JS]

description: ES6中的let、const与解构赋值
---

## 又开新坑 

今天登录博客一看，发现自己一个月没有写博客了，想想时间也过得挺快，这个月又在前端路上迈出了小小一步，开心。上个月开的Node.js坑还没填，因为在写博客的过程中发现自己好多东西还没搞懂，之后会补起Node.js的坑。

## ES6

我们先来看看ES6的新特性：

+ let、const定义变量
+ 解构赋值
+ ES6函数
+ 数据类型Symbol
+ ES6对象
+ ES6数组
+ 数据结构Set和Map
+ Promise和Generator
+ 迭代器和for of遍历
+ Class
+ Module

我们一点一点慢慢过，我相信你在学完后一定会觉得ES6真爽！

### let、const定义变量

在说```let```与```const```之前，我们先来看看之前编码时一直使用的好朋友```var```，```var```确实蛮好用的，但它也存在许多问题，比较烦人的就是由于没有块级作用域，for循环变量会被共享。

举个栗子

	for (var i = 0; i < 3; i++) {
		setTimeout(function () {
			console.log(i);
		}, 100);
	}
	//3 3 3

最后输出的```3 3 3```很明显不是我们所想要的结果

	for (var i = 0; i < 3; i++) {
		;(function (i) {
			setTimeout(function () {
				console.log(i);
			}, 100);
		})(i);
	}
	//0 1 2

上面这段代码是我们之前的解决方法，采用了闭包，每次for循环时都用新的内存空间去储存```i```，看似是解决了这个问题，但是又引来了新的问题：如果这段代码是在全局作用域下，便会新添一个全局变量```i```。我们来看看使用let后如何解决这个问题

	for (let i = 0; i < 3; i++) {
		setTimeout(function () {
			console.log(i);
		}, 100);
	}
	//0 1 2
	console.log(i);
	//err: i is not defined

```let```可以帮助我们完美的解决这个问题，且不会污染作用域。使用```let```需要注意不要在同一块级作用域中重复定义，且```let```不存在变量的预解析（变量的提升）。

聊完了```let```我们再来看看```const```。```const```说明白就是个静态变量，这个变量在定义后就不能修改。

	const PI = 3.14;

	PI = 3; //报错

有了```const```，你就可以将所有你认为不会改变的变量“保护”起来了。在同一块级作用域中使用```const```重新定义并不会报错，只会默默的失败，同```let```一样，```const```也不存在变量提升。

使用```const```定义的变量最好全大写，单词之间使用```_```隔开。

最后提一下，在之前我们通过闭包的方式在创建块级作用域，现在只需要

	{
		//dosomething
	}

爽不爽？

### 解构赋值

再说解构变量之前，我们先说一个小细节，不知道各位是否注意到一般插件自动生成的DOM解构中在```html```标签会存在一个```lang```属性，一般默认为```<html lang="en">```，这样会有一个小问题，就是用户在访问时浏览器会出现一个窗口询问是否翻译，如果你做的是中文站，推荐将其修改为```<html lang="zh">```。

什么是解构赋值？大家可以先理解为变量的批量赋值，我们用代码说话

	let arr = [1, [, 2.1, 2.2], 3];

先定义一个数组```arr```，如果我们想将其每个元素单独储存起来，需要

	let a = arr[0];
	let b = arr[1];
	let c = arr[2];
	
	console.log(a, b, c); //1, [, 2.1, 2.2], 3

而使用解构赋值，只需要

	let [a, b, c] = arr;
	console.log(a, b, c); //1, [, 2.1, 2.2], 3

是不是有点感觉了？那如果我需要将b中的元素也取出来呢？

	let [a, [b1, b2, b3], c] = arr;
	console.log(a, b1, b2, b3, c); //1, undefined, 2.1, 2.2, 3

这样我们就将每个元素都取了出来。但如果我只想要2.1这个值呢？

	let [, [, b2]] = arr;
	console.log(b2); //2.1

现在大家有没有对解构赋值了解一些，之前我们说解构赋值是批量赋值，现在我们重新定义一下，解构赋值就是把右侧的数据类型复制到左侧构造的相似的数据类型中。

接下来我们介绍一个新东西，拓展运算符，依旧是代码说话。

	let arr = [1, [, 2.1, 2.2], 3, 4, 5];

现在我需要取出```arr```数组中的第一个元素，第二个元素，以及剩余所有的元素呢？

	let [a, b, ...other] = arr;

	console.log(a, b, other); //1, [1: 2.1, 2: 2.2], [3, 4, 5]

这个```...```就是拓展运算符，它会取剩余的所有元素，因此他只能出现在参数末尾，不能出现在参数中间。

更多关于拓展运算符的用法会在之后与函数配合介绍。

使用解构赋值还存在一个越界问题

	let arr = [1, 2];
	let [x, y, z] = arr;
	console.log(x, y, z); 
	//1 2 undefined

其里```z```相当于```arr[2]```，而数组```arr```中只有两个元素，因此```z```取值```undefined```。

看完了数组的解构赋值我们再来看对象的，现在我们有一个对象

	let obj = {
		a: 'a',
		b: 'b',
		c: 'c',
		arr: [1, 2, 3]
	};

要如何取得```a```、```b```、```c```三个属性的值并将其赋值给```x```、```y```、```z```呢？聪明的你肯定想到了

	let {x, y, z} = obj;

	console.log(x, y, z);

然后你就会发现三个```undefined```，一脸懵比。为什么会这样呢？

上面这段代码其实等价于

	let x = obj.x;
	let y = obj.y;
	let z = obj.z;

而对象obj中并没有```x```、```y```、```z```三个属性，因此我们只能通过

	let {a, b, c} = obj;

	console.log(a, b, c); // a b c 

有的同学就问了，你说好的赋值给```x```，```y```和```z```呢，别暴躁，我们可以这样解决

	let {a: x, b: y, c: z} = obj;

	console.log(x, y, z); // a b c 

有的同学会说6啊，但我还想要拿到```obj.arr```里的第三个元素呢？

	let {a: x, b: y, c: z, arr: [, , three]} = obj;

	console.log(x, y, z, three); // a b c 3 

6不6，这里大家可以好好理解一下，搞懂了解构赋值会使你之后码代码更加舒服。

ES6从入门到放弃第一节就到这里，下节我们将会讲ES6中函数的一些新特性，期待着吧:)







