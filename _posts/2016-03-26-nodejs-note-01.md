---
layout: post

title: NodeJS从入门到放弃-基础

date: 2016-03-26

categories: blog

tags: [NodeJS]

description: NodeJS学习笔记-从零开始
---

## 为什么要学习NodeJS

其实在学PHP的时候我就想写写学习后端的理由了，随着前端学习的不断深入，有时候觉得不会后端好受限制，便决定学门后端语言了，但是学PHP还是NodeJS呢？这又是个问题，不过好在没有难倒我，我两门一起学！不过可能更侧重NodeJS吧，逼近离我大JS近一些。

我是跟着慕课网[进击的Node.js](http://www.imooc.com/video/6693)课程学习的，想要看视频的同学可以前往学习。

### 安装Node

因为目前我使用的Mac，因此只在此展示OS X系统下Node的安装，其他系统的同学可自行搜索。

+ 升级Xcode

    在终端输入
    ```
    xcode-select -p
    ```
    如果返回路径信息，则说明安装过，如果没有安装过，而可以通过
    ```
    xcode-select --install
    ```
    来安装Xcode

+ 安装Homebrew

    Homebrew是OS X下的套件管理器
    可以在官网[brew.sh](http://brew.sh)自行下载，或复制下面的代码到终端回车进行安装。

    ```
    /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
    ```

    Homebrew依赖于ruby，如果安装出了问题，可以检查一下ruby安装的路径有没有问题

    ```
    ruby -v
    ```

+ 安装Node

    Homebrew安装成功后我们就可以安装Node了，在终端敲

    ```
    brew install Node
    ```

    除了Node外，还可以通过brew安装git、mongodb等，可以连起来写

    ```
    brew install git mongodb
    ```

    等待安装完成后，可以输入

    ```
    node -v
    ```

    如果返回版本号，就说明安装成功啦

### 搭一个web服务器

在本地新建一个文件夹Node，在Node下新建一个子文件夹beginning，在子文件夹下新建一个JS文件，叫server.js，将下面的代码复制上去，保存。

    var http = require('http');

    var server = http.createServer(function (req, res) {
        res.writeHead(200, {'content-Type': 'text/plain'});
        res.end('Hello NodeJS\n');
    });

    server.listen(1337, '127.0.0.1');

    console.log('Server running at http://127.0.0.1:1337');

打开终端，通过```cd```命令进入beginning这个文件夹

    cd node/beginning

如果只输入```cd```，则会返回你的home folder。与HTML类似，你同样可以使用```cd ..```返回上级目录。

查看当前文件夹下的文件可用命令```ls```。

移动到beginning后，输入

    node server.js

你会看到之前写好的console

    Server running at http://127.0.0.1:1337   

如果没有看到这句，请检查之前的步骤，慢慢折腾，直到看到为止。

如果看到了这句，就可以在浏览器中输入127.0.0.1:1337或localhost:1337，你会看到“Hello NodeJS”，一个简单的web服务器就搭起来了，有请求，有回复，是不是还有点小兴奋啊^ ^

现在我们回过头去看之前那段代码

    //加载一个http模块，由JS编写，其职责为创建web服务器及处理http相关任务等
    var http = require('http');

    //通过createServer()来创建一个web服务器
    //当监听到请求时，我们需要告诉NodeJS下一步应该做什么，因此我们传入了一个匿名回调函数
    //匿名回调函数有两个参数，分别是 req：请求体(request) res：响应体(response)
    var server = http.createServer(function (req, res) {
        //在返回的请求头里写入状态码：200，代码成功，返回的文本类型为纯文本
        res.writeHead(200, {'content-Type': 'text/plain'});
        //给浏览器返回一个Hello NodeJS
        res.end('Hello NodeJS\n');
    });

    //通过listen()来监听1337端口的请求
    server.listen(1337, '127.0.0.1');

    console.log('Server running at http://127.0.0.1:1337');

接着，我们修改```Hello NodeJS\n```为```Hello Xx```，刷新页面，看看会发生什么。

是的，你会发现什么也没有发生，这因为我们没有重新启动服务器。在终端按下```CTRL + C```，就可以停掉之前的服务，然后重新启动服务器，刷新页面就会看到变化啦。

### NodeJS的模块

我们知道，在JS中，我们可以定义全局变量，但是在多人协作，或者大量的JS文件批量的引入的时候，很容易出现变量被覆盖掉，方法被重写掉等问题，这是因为JS天生就缺少一种模块管理机制，来隔离实现不同功能的JS片断，避免它们相互污染，为此我们经常采用命名空间的方式，将变量与函数限制在某个特定的作用域内，从而保证代码的执行。

说起NodeJS就提一下Commonjs，Commonjs不同于NodeJS或JQuery这种具体负责某个职能的JS库，它是一套规范，包括了模块、系统、二进制、控制台编码、单元测试等，来约定JS应该怎么去组织、编写。不同的功能会分为不同的模块，而模块彼此又不孤立，每个模块又分为模块的定义，标识与引用，而NodeJS则是对Commonjs规范的实现。

在NodeJS中，模块与文件是一一对应的，模块有几种不同的类型，大概可分为核心模块、文件模块与第三方模块，根据模块类型，有不同的引入方式。

#### 模块的流程

+ 创建模块

+ 导出模块

+ 加载模块

+ 使用模块

之后我们将横扫API，[点击这里](http://nodeapi.ucdok.com/#/api/url.html)可以查看NodeJS API 中文版。

### URL网址解析

uri与url是什么？

+ uri是统一资源标识符，字符串格式规范，不一定是url，是一种抽象化的概念

+ url是统一资源定位符，一定是一个uri，是uri的一个子集

在NodeJS中，URL模块有三个方法，分别为```parse()```、```format()```与```resolve()```。它们分别是用来做什么的呢？

```parse()```，顾名思义就是解析，它可以输入一个URL字符串，并返回一个对象

打开终端，输入```node```，进入NodeJS环境，输入url可以查看到url模块的方法提示

    //使用parse方法解析URL
    > url.parse('http://xxthink.com/archive/')
    //返回一个URL对象
    Url {
    protocol: 'http:', //指定底层制定的协议，如http、ftp等
    slashes: true, //是否有协议的双斜线
    auth: null,
    host: 'xxthink.com', //http服务器的ip地址，或域名
    port: null, //端口，默认为80
    hostname: 'xxthink.com', //主机名
    hash: null, //哈希值，通常对应的是页面上的锚点
    search: null, //查询字符串参数
    query: null, //发送给http服务器的数据
    pathname: '/archive/', //访问资源的路径名
    path: '/archive/', //路径
    href: 'http://xxthink.com/archive/' } //一个没被解析的完整的超链接

    //再试试用parse解析一个新的url http://xxthink.com:8080/archive?uname=xx#nav

我们可以看到，在```parse()```中只传入一个参数，解析出来的对象的query属性为一个字符串，但很多时候我们需要并不是这样一个字符串，这时候我们就该用到第二个参数，默认为false，将其改为true，看看会出现什么。

    > url.parse('http://xxthink.com:8080/archive?uname=xx&type=get#nav', true);
    Url {
    protocol: 'http:',
    slashes: true,
    auth: null,
    host: 'xxthink.com:8080',
    port: '8080',
    hostname: 'xxthink.com',
    hash: '#nav',
    search: '?uname=xx&type=get',
    query: { uname: 'xx', type: 'get' },
    pathname: '/archive',
    path: '/archive?uname=xx&type=get',
    href: 'http://xxthink.com:8080/archive?uname=xx&type=get#nav' }

query属性被解析成了一个对象，我们可以更方便的操作啦。

```parse()```方法除了前两个参数外，还有第三个参数，将第三个参数设置为```true```来把诸如```//foo/bar```这样的URL解析为```{ host: 'foo', pathname: '/bar' }```而不是```{ pathname: '//foo/bar' }```。默认为```false```。有兴趣的同学可以自行尝试，这里就不演示了。

```format()```，输入一个URL对象，返回格式化后的URL字符串

```format()```方法与```parse()```方法刚好相反，我们可以试着将```parse()```方法解析出来的对象传入```format()```

    > url.format({
        protocol: 'http:',
        slashes: true,
        auth: null,
        host: 'xxthink.com:8080',
        port: '8080',
        hostname: 'xxthink.com',
        hash: '#nav',
        search: '?uname=xx',
        query: 'uname=xx',
        pathname: '/archive',
        path: '/archive?uname=xx',
        href: 'http://xxthink.com:8080/archive?uname=xx#nav' })
    //返回一个完整的URL字符串
    'http://xxthink.com:8080/archive?uname=xx#nav'

```resolve()```，给定一个基础的URL路径，和一个herf URL路径，并且象浏览器那样处理他们可以带上锚点

     url.resolve('http://xxthink.com', 'about')
     //将两段拼为了一个完整的url路径
    'http://xxthink.com/about'

URL模块虽然简单，但非常重要，只要涉及到网络请求的接受，路径参数的处理，就会方便的解析URL，从而判断请求类型等。
